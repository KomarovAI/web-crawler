name: Deploy to GitHub Pages

on:
  workflow_dispatch:
    inputs:
      source_run_id:
        description: 'Source workflow run ID (from download-site.yml)'
        required: true
        type: string
      artifact_name:
        description: 'Artifact name to deploy (e.g. site-archive-12345)'
        required: true
        type: string
      target_repo:
        description: 'Target repository for Pages (owner/repo)'
        required: true
        type: string
        default: 'KomarovAI/web-crawler-pages'
      clean_warc:
        description: 'Remove WARC/WARC.gz files (GitHub 100MB limit)'
        required: false
        type: boolean
        default: true
      rewrite_links:
        description: 'Rewrite URLs to local paths'
        required: false
        type: boolean
        default: true
      resumeUrl:
        description: 'n8n webhook callback URL'
        required: false
        type: string

permissions:
  contents: read
  actions: read

jobs:
  deploy-pages:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    timeout-minutes: 60

    steps:
      - name: Validate inputs
        id: validate
        run: |
          SOURCE_RUN_ID="${{ github.event.inputs.source_run_id }}"
          TARGET_REPO="${{ github.event.inputs.target_repo }}"
          ARTIFACT_NAME="${{ github.event.inputs.artifact_name }}"
          
          if [[ ! "$SOURCE_RUN_ID" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Error: source_run_id must be numeric"
            exit 1
          fi
          
          if [[ ! "$TARGET_REPO" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
            echo "‚ùå Error: target_repo format invalid (use owner/repo)"
            exit 1
          fi
          
          echo "source_run_id=$SOURCE_RUN_ID" >> $GITHUB_OUTPUT
          echo "target_repo=$TARGET_REPO" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Validation passed"

      - name: Checkout source repo (for scripts)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ steps.validate.outputs.artifact_name }}
          path: ./artifact-download
          repository: ${{ github.repository }}
          run-id: ${{ steps.validate.outputs.source_run_id }}

      - name: Extract and verify archive
        id: extract
        run: |
          cd ./artifact-download
          
          ARCHIVE_DIR=$(find . -maxdepth 1 -name "archive_*" -type d | head -1)
          if [ -z "$ARCHIVE_DIR" ]; then
            echo "‚ùå Archive not found"
            echo "üìÅ Contents:"
            ls -la
            exit 1
          fi
          
          DOMAIN=$(basename "$ARCHIVE_DIR" | sed 's/archive_//' | sed 's/_/./g')
          FILE_COUNT=$(find "$ARCHIVE_DIR" -type f | wc -l)
          SIZE=$(du -sh "$ARCHIVE_DIR" | cut -f1)
          
          echo "archive_dir=$ARCHIVE_DIR" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "size=$SIZE" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Archive verified: $DOMAIN ($FILE_COUNT files, $SIZE)"

      - name: Format and initialize target repository
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_REPO: ${{ steps.validate.outputs.target_repo }}
        run: |
          set -e
          
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          echo "üìÇ Full repository format - destructive reset"
          echo "üìÑ Cloning $TARGET_REPO"
          
          git clone "https://oauth2:${GH_TOKEN}@github.com/${TARGET_REPO}.git" . 2>&1 || {
            echo "‚ÑπÔ∏è  First deploy - initializing new repo"
            git init
            git remote add origin "https://oauth2:${GH_TOKEN}@github.com/${TARGET_REPO}.git"
          }
          
          echo "üóëÔ∏è  Cleaning repository - removing ALL content"
          
          # Remove ALL files except .git
          find . -maxdepth 1 -type f -delete
          find . -maxdepth 1 -type d ! -name '.git' -exec rm -rf {} + 2>/dev/null || true
          
          # Verify .git is still there
          if [ ! -d ".git" ]; then
            echo "‚ö†Ô∏è  .git was removed, reinitializing"
            git init
            git remote add origin "https://oauth2:${GH_TOKEN}@github.com/${TARGET_REPO}.git"
          fi
          
          echo "üìÑ Creating fresh gh-pages branch (orphan)"
          
          # Create orphan gh-pages branch
          git checkout --orphan gh-pages 2>/dev/null || git checkout gh-pages
          git rm -rf . 2>/dev/null || true
          
          echo "üíæ Creating .nojekyll file"
          touch .nojekyll
          
          git add .nojekyll
          git commit -m "chore: Initialize gh-pages branch" || true
          
          echo "$TEMP_DIR" > /tmp/target_dir
          echo "‚úÖ Repository fully reset and ready for deployment"

      - name: Deploy archive to clean repository
        id: deploy
        run: |
          TEMP_DIR=$(cat /tmp/target_dir)
          cd "$TEMP_DIR"
          
          echo "üìÅ Extracting archive to root"
          ARCHIVE_PATH="$GITHUB_WORKSPACE/artifact-download/${{ steps.extract.outputs.archive_dir }}"
          
          # Copy all archive contents to root of target repo
          cp -rv "$ARCHIVE_PATH"/* . 2>/dev/null || true
          
          # Ensure .nojekyll exists
          touch .nojekyll
          
          # Count final files
          FINAL_FILE_COUNT=$(find . -type f ! -path './.git*' | wc -l)
          FINAL_SIZE=$(du -sh . | cut -f1)
          
          echo "final_files=$FINAL_FILE_COUNT" >> $GITHUB_OUTPUT
          echo "final_size=$FINAL_SIZE" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Archive deployed: $FINAL_FILE_COUNT files ($FINAL_SIZE)"

      - name: Clean WARC files
        if: github.event.inputs.clean_warc == 'true'
        run: |
          TEMP_DIR=$(cat /tmp/target_dir)
          cd "$TEMP_DIR"
          
          echo "üßπ Scanning for WARC files"
          WARC_COUNT=$(find . -name "*.warc" -o -name "*.warc.gz" | wc -l)
          
          if [ $WARC_COUNT -gt 0 ]; then
            echo "üóëÔ∏è  Removing $WARC_COUNT WARC files"
            find . -name "*.warc" -o -name "*.warc.gz" | xargs rm -f
            echo "‚úÖ WARC files removed"
          else
            echo "‚úÖ No WARC files found"
          fi

      - name: Rewrite URLs to local paths
        if: github.event.inputs.rewrite_links == 'true'
        continue-on-error: true
        run: |
          TEMP_DIR=$(cat /tmp/target_dir)
          cd "$TEMP_DIR"
          
          echo "üîó Rewriting URLs for domain: ${{ steps.extract.outputs.domain }}"
          
          python3 << 'PYTHON'
          import os
          import re
          from pathlib import Path
          
          DOMAIN = "${{ steps.extract.outputs.domain }}"
          SAFE_DOMAIN = re.escape(DOMAIN)
          
          # URL rewrite patterns - aggressive matching
          patterns = [
              # href URLs (quoted)
              (rf'href=["\']https?://{SAFE_DOMAIN}([/a-zA-Z0-9._~:/?#@!$&\'()*+,;=%-]*)["\'']',
               r'href="\1"'),
              # src URLs
              (rf'src=["\']https?://{SAFE_DOMAIN}([/a-zA-Z0-9._~:/?#@!$&\'()*+,;=%-]*)["\'']',
               r'src="\1"'),
              # action URLs (forms)
              (rf'action=["\']https?://{SAFE_DOMAIN}([/a-zA-Z0-9._~:/?#@!$&\'()*+,;=%-]*)["\'']',
               r'action="\1"'),
              # srcset (images)
              (rf'srcset=["\']https?://{SAFE_DOMAIN}([^"\']*)["\'']',
               r'srcset="\1"'),
              # data URLs
              (rf'data=["\']https?://{SAFE_DOMAIN}([/a-zA-Z0-9._~:/?#@!$&\'()*+,;=%-]*)["\'']',
               r'data="\1"'),
              # Unquoted URLs in JavaScript
              (rf'https?://{SAFE_DOMAIN}(/[a-zA-Z0-9._~:/?#@!$&\'()*+,;=%-]*)',
               r'\1'),
          ]
          
          # File extensions to process
          PROCESS_EXTS = {'.html', '.htm', '.js', '.css', '.json', '.xml', '.svg'}
          
          modified_count = 0
          error_count = 0
          
          for root, dirs, files in os.walk('.'):
              # Skip .git directory
              if '.git' in dirs:
                  dirs.remove('.git')
              
              for file in files:
                  ext = Path(file).suffix.lower()
                  if ext in PROCESS_EXTS:
                      filepath = os.path.join(root, file)
                      try:
                          with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                              original = f.read()
                          
                          content = original
                          for pattern, replacement in patterns:
                              content = re.sub(pattern, replacement, content, flags=re.IGNORECASE)
                          
                          if content != original:
                              with open(filepath, 'w', encoding='utf-8') as f:
                                  f.write(content)
                              modified_count += 1
                      except Exception as e:
                          error_count += 1
                          if error_count <= 5:
                              print(f"‚ö†Ô∏è  Error in {filepath}: {str(e)[:100]}")
          
          print(f"‚úÖ Rewrote {modified_count} files")
          if error_count > 5:
              print(f"‚ö†Ô∏è  {error_count - 5} more errors (not shown)")
          PYTHON

      - name: Commit and force push to gh-pages
        id: commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TEMP_DIR=$(cat /tmp/target_dir)
          cd "$TEMP_DIR"
          
          echo "üìã Staging changes"
          git add -A
          
          # Check for changes
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit (empty archive?)"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          DOMAIN="${{ steps.extract.outputs.domain }}"
          SOURCE_RUN="${{ steps.validate.outputs.source_run_id }}"
          
          echo "üìù Creating commit"
          git commit -m "chore(pages): Deploy $DOMAIN from web-crawler" \
                     -m "" \
                     -m "Source Information:" \
                     -m "  Run ID: $SOURCE_RUN" \
                     -m "  Domain: $DOMAIN" \
                     -m "  Deployment Run: ${{ github.run_id }}" \
                     -m "" \
                     -m "Archive Details:" \
                     -m "  Files: ${{ steps.extract.outputs.file_count }}" \
                     -m "  Size: ${{ steps.extract.outputs.size }}" \
                     -m "" \
                     -m "Deployment Details:" \
                     -m "  Final Files: ${{ steps.deploy.outputs.final_files }}" \
                     -m "  Final Size: ${{ steps.deploy.outputs.final_size }}" \
                     -m "  Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          echo "üöÄ Force pushing to gh-pages (complete reset)"
          git push -u origin gh-pages --force
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Successfully deployed (full reset + push)"

      - name: Create GitHub Pages deployment summary
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<'EOF'
          ## üöÄ GitHub Pages Deployment Complete
          
          ### Deployment Status
          | Property | Value |
          |----------|-------|
          | **Status** | ${{ job.status }} |
          | **Source Run** | ${{ steps.validate.outputs.source_run_id }} |
          | **Target Repo** | ${{ steps.validate.outputs.target_repo }} |
          | **Branch** | gh-pages |
          | **Reset Type** | Full Format (Orphan Branch) |
          
          ### Archive Information
          | Property | Value |
          |----------|-------|
          | **Domain** | ${{ steps.extract.outputs.domain }} |
          | **Original Files** | ${{ steps.extract.outputs.file_count }} |
          | **Original Size** | ${{ steps.extract.outputs.size }} |
          | **Final Files** | ${{ steps.deploy.outputs.final_files }} |
          | **Final Size** | ${{ steps.deploy.outputs.final_size }} |
          | **Changes Committed** | ${{ steps.commit.outputs.has_changes }} |
          
          ### üìç GitHub Pages URL
          \`https://$(echo '${{ steps.validate.outputs.target_repo }}' | cut -d'/' -f1).github.io/$(echo '${{ steps.validate.outputs.target_repo }}' | cut -d'/' -f2)/\`
          
          ### Notes
          - üóëÔ∏è Repository fully formatted before deployment
          - üßπ WARC files cleaned
          - üîó URLs rewritten to local paths
          - üëë Force pushed to gh-pages (clean history)
          
          EOF

      - name: Notify n8n on completion
        if: always() && github.event.inputs.resumeUrl != ''
        continue-on-error: true
        run: |
          RESUME_URL="${{ github.event.inputs.resumeUrl }}"
          
          if [ -z "$RESUME_URL" ]; then
            echo "‚Ü©Ô∏è  No resumeUrl provided"
            exit 0
          fi
          
          echo "üì° Sending callback to n8n..."
          
          OWNER=$(echo '${{ steps.validate.outputs.target_repo }}' | cut -d'/' -f1)
          REPO=$(echo '${{ steps.validate.outputs.target_repo }}' | cut -d'/' -f2)
          PAGES_URL="https://${OWNER}.github.io/${REPO}/"
          
          PAYLOAD=$(cat <<EOF
          {
            "status": "${{ job.status }}",
            "workflow": "deploy-pages",
            "run_id": ${{ github.run_id }},
            "source_run_id": ${{ steps.validate.outputs.source_run_id }},
            "target_repo": "${{ steps.validate.outputs.target_repo }}",
            "domain": "${{ steps.extract.outputs.domain }}",
            "original_files": "${{ steps.extract.outputs.file_count }}",
            "original_size": "${{ steps.extract.outputs.size }}",
            "final_files": "${{ steps.deploy.outputs.final_files }}",
            "final_size": "${{ steps.deploy.outputs.final_size }}",
            "pages_url": "${PAGES_URL}",
            "reset_type": "full-format",
            "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          }
          EOF
          )
          
          curl -k -X POST "$RESUME_URL" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            --retry 3 \
            --retry-delay 5 \
            --connect-timeout 10 \
            --max-time 30 \
            -w "\n‚úÖ n8n callback sent (HTTP %{http_code})\n" \
            || echo "‚ö†Ô∏è  n8n callback failed (non-critical)"
