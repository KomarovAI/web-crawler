#!/usr/bin/env python3
\"\"\"\nExport SQLite archive to standard WARC format\nISO 28500:2017 compliant\n\"\"\"\n\nimport sqlite3\nimport gzip\nimport uuid\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nimport sys\n\ndef export_to_warc(db_path: str, warc_output_path: str):\n    \"\"\"Export SQLite archive to WARC format\"\"\"\n    \n    conn = sqlite3.connect(db_path)\n    conn.row_factory = sqlite3.Row\n    cursor = conn.cursor()\n    \n    with gzip.open(warc_output_path, 'wt', encoding='utf-8') as warc_file:\n        # Write WARC info record\n        warc_file.write(write_warc_info_record(db_path))\n        \n        # Export all pages\n        cursor.execute('SELECT * FROM pages ORDER BY extracted_at')\n        page_count = 0\n        for page in cursor.fetchall():\n            warc_file.write(write_warc_response_record(page))\n            page_count += 1\n        \n        # Export all assets\n        cursor.execute('''\n            SELECT a.*, ab.content\n            FROM assets a\n            JOIN asset_blobs ab ON a.content_hash = ab.content_hash\n            ORDER BY a.extracted_at\n        ''')\n        asset_count = 0\n        for asset in cursor.fetchall():\n            warc_file.write(write_warc_resource_record(asset))\n            asset_count += 1\n    \n    conn.close()\n    \n    print(f\"\\u2705 Exported to WARC:\")\n    print(f\"  File: {warc_output_path}\")\n    print(f\"  Pages: {page_count}\")\n    print(f\"  Assets: {asset_count}\")\n    print(f\"  Format: WARC/1.1 (ISO 28500:2017)\")\n\ndef write_warc_info_record(db_path: str) -> str:\n    \"\"\"Create WARC-Info record\"\"\"\n    record_id = f'urn:uuid:{uuid.uuid4()}'\n    timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')\n    \n    db_size = Path(db_path).stat().st_size\n    \n    info_json = json.dumps({\n        \"software\": \"SmartArchiver/2.0\",\n        \"creator\": \"SmartArchiver\",\n        \"isPartOf\": \"Web Archive\",\n        \"conformsTo\": \"https://iipc.github.io/warc-specifications/specifications/warc-1.1/\",\n        \"format\": \"WARC\",\n        \"version\": \"1.1\"\n    })\n    \n    record = f\"\"\"WARC/1.1\nWARC-Type: info\nWARC-Record-ID: <{record_id}>\nWARC-Date: {timestamp}\nWARC-Content-Length: {len(info_json)}\nContent-Type: application/json\n\n{info_json}\n\n\"\"\"\n    return record\n\ndef write_warc_response_record(page) -> str:\n    \"\"\"Create WARC-Response record from page\"\"\"\n    record_id = page['warc_id'] if page['warc_id'] else f'urn:uuid:{uuid.uuid4()}'\n    timestamp = page['extracted_at'].replace(' ', 'T') + 'Z' if ' ' in page['extracted_at'] else page['extracted_at']\n    \n    # Simple HTTP response header\n    http_response = f\"\"\"HTTP/1.1 {page['status_code']} OK\nContent-Type: text/html; charset=utf-8\nContent-Length: {page['content_length']}\nDate: {timestamp}\n\n\"\"\"\n    \n    record = f\"\"\"WARC/1.1\nWARC-Type: response\nWARC-Target-URI: {page['url']}\nWARC-Date: {timestamp}\nWARC-Record-ID: <{record_id}>\nWARC-Content-Length: {len(http_response)}\nWARC-Payload-Digest: {page['payload_digest'] or 'sha256:0000000000000000000000000000000000000000'}\nWARC-Block-Digest: {page['block_digest'] or 'sha256:0000000000000000000000000000000000000000'}\nContent-Type: application/http; msgtype=response\n\n{http_response}\n\n\"\"\"\n    return record\n\ndef write_warc_resource_record(asset) -> str:\n    \"\"\"Create WARC-Resource record from asset\"\"\"\n    record_id = f'urn:uuid:{uuid.uuid4()}'\n    timestamp = asset['extracted_at'].replace(' ', 'T') + 'Z' if ' ' in asset['extracted_at'] else asset['extracted_at']\n    \n    content = asset['content']\n    if isinstance(content, str):\n        content = content.encode('utf-8')\n    \n    record_header = f\"\"\"WARC/1.1\nWARC-Type: resource\nWARC-Target-URI: {asset['url']}\nWARC-Date: {timestamp}\nWARC-Record-ID: <{record_id}>\nWARC-Content-Length: {len(content)}\nContent-Type: {asset['mime_type'] or 'application/octet-stream'}\n\n\"\"\"\n    \n    # Note: Binary content would need special handling in real implementation\n    return record_header + \"\\n\"\n\nif __name__ == '__main__':\n    db_path = sys.argv[1] if len(sys.argv) > 1 else 'archive.db'\n    warc_output = sys.argv[2] if len(sys.argv) > 2 else 'archive.warc.gz'\n    \n    if not Path(db_path).exists():\n        print(f\"Error: Database not found: {db_path}\")\n        sys.exit(1)\n    \n    export_to_warc(db_path, warc_output)\n